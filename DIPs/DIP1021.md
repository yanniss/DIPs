# Resolution of Alias Template Parameters in Function Templates

| Field           | Value                                                      |
|-----------------|------------------------------------------------------------|
| DIP:            | 1021                                                       |
| Author:         | Stefanos Baziotis (sdi1600105@di.uoa.gr)                   |

## Abstract

D has type aliases that can be templates:
```
struct TestType(T) { }
alias TestAlias(T) = TestType!T
```

Moreover, D has function templates, whose type parameters are inferred when the function is called:
```
struct TestType(T) { }
TestType!int testArg;
void testFunc(TestType!T arg) { }
testFunc(testArg); /* template instantiated with T = int */
```

Combining alias templates and function templates, we would want to be able to have alias templates
as formal parameter types of function templates:
```
struct TestType(T) { }
alias TestAlias(T) = TestType!T
void testFunc(TestAlias!T arg) { }
```

However, the compiler produces an error when such a function is called with a value having an (instantiated) alias template type. This is not a bug, because the desired behaviour is not specified. Thus, although there are Bugzilla reports (see links below), these are tagged as 'Enhancements'.

This DIP proposes a specification of how alias template formal parameters in template functions should be handled.

### Links
#### From the forum
- [GSoC 2019 Mir Project Ideas - DataFrame Project](https://forum.dlang.org/post/jyzgzxqgaggltgifwnxx@forum.dlang.org)
- [Initial idea from Ilya Yashorenko](https://forum.dlang.org/post/kvcrsoqozrflxibgxtlo@forum.dlang.org)
#### Bugzilla reports
- [16486](https://issues.dlang.org/show_bug.cgi?id=16486)
- [16465](https://issues.dlang.org/show_bug.cgi?id=16465)
#### Pull request with a 3-day prototype implementation
- https://github.com/dlang/dmd/pull/9778
#### An article that describes the problem in a simple way and focuses more on the implementation challenges
- [Alias Templates as Function Parameters](http://users.uoa.gr/~sdi1600105/dlang/alias.html)

## Description
**Currently**: An alias template function parameter is not resolved to its aliased instance until after the function
resolution stage. So, with the following code:
```
struct TestType(T) {}
alias TestAlias(T) = TestType!T;
void testFunction(T)(TestAlias!T arg) {}

void main()
{
    TestAlias!int testObj;
    testFunction(testObj); /* "cannot deduce function from argument types !()(TestType!int)" */
}
```
We get the following error message:
```
template testFunction cannot deduce function from argument types !()(TestType!int), candidates are:
testFunction(T)(TestAlias!T arg)
```
The compiler sees `TestAlias` and `TestType` as two different types, and so it can't match `TestType!int` against
`TestAlias!T`. Although the compiler has resolved the type of `testObj` to `TestType!int`, it has not resolved the 
formal parameter type to be `TestType!T`.

## Rationale

It is quite common for a series of (one or more) nested template instantiations to be considered as one semantic entity, especially
for data science libraries.
Consider the following D template function:
```
auto foo(T)(Slice!(StairsIterator!(T*, "-")) m)
{
}
```

A lot of users of the Mir library would want to be able to do something like this:
```
alias PackedUpperTriangularMatrix(T) = Slice!(StairsIterator!(T*, "-"));

// fails, issue 16486
auto foo(T)(PackedUpperTriangularMatrix!T m) { }
```

Packing the RHS instances in a nice alias is not only a way to reduce code size but most importantly,
it removes the burden from the user to know what a `PackedUpperTriangularMatrix` actually is. Right now,
the user is exposed to unnecessary details, leading to code that is not as easy to comprehend. People seem
to pay money for this feature to be implemented.

## Proposal

Full handling of the feature is complicated because an alias template has arbitrary pattern matching and rewrite abilities over types. For instance, an alias template:
 * can accept type parameters that it never uses (e.g., `alias TestAlias(T) = int;`)
 * can accept a type parameter and use it multiple times (e.g., `alias TestAlias(T) = TemplateType!(T,T);`)
 * can infer a type parameter when given a complex type expression (e.g., `alias TestAlias(A: A*, B) = TemplateType!(A, B);`).
 
Therefore, the crux of the proposal is to encode this pattern matching and type rewriting into a function, `Gen`, and invoke it at the right time during compilation.

Specifically, if the type of the formal parameter of a function template is an instance of an alias template declaration, instantiate the type that the declaration
aliases and that is the new type of the parameter. This should be done before function calls are resolved.
In pseudocode:
```
while ( parameterType == Gen(TD, (T1, T2, ..., Tn)) ) {
    if (TD is aliasTemplateDeclaration) {
        aliasedType = TD.aliasedType;
        if (aliasedType is TemplateInstance) {
            newTD = findTempDecl(aliasedType);
            newArgumentList = matchParams(aliasedType.argumentList, parameterType.paramMap);
            parameterType = Gen(newTD, newArgumentList);
        } else {
            parameterType = aliasedType;
        }
    }
}
```

`Gen` is a function that takes 2 arguments, `TD` and the list `T1, ..., Tn`.
`TD` is a template declaration.
`T1, ..., T2` are arguments (actual parameters) provided to a template declaration.
The expression `Gen(TD, (T1, ..., Tn)` generates an instance of the declaration `TD` when `T1, ..., Tn` are provided
as arguments. It additionally fills `parameterType.paramMap` which maps each formal parameter to the corresponding argument.
A template argument can be: <br/>
1) A type declarator referencing known types like `int`, `int*`, `int[long]` etc.
2) A type declarator using a template declaration formal parameter like `T`, `T*`, etc.
3) A type declarator using both known types and formal parameters, like `T[int]`.
For 2) to be true, the instantiation should happen inside a template declaration. In this case, the formal parameters
that are used by any argument must be a subset of the formal parameters of the declaration. <br/>
**Additional notes**:
- The number of arguments must be the same with the number of formal parameters of the template declaration.
- The argument list may contain duplicate elements.
- The generation should take into consideration the pattern-matching capabilities provided by D in template parameters.
Examples:
```
Gen(struct TestType(T) { }, (int*)) -> TestType!(int*)
Gen(struct TestType(T) { }, (T[int])) -> TestType!(T[int])
Gen(alias TestAlias(T) = TestType!T, (int*)) -> TestAlias!(int*)
Gen(alias TestAlias(T, Q) = TestType!T, (int*)) -> TestAlias!(int*)
```

So, the loop condition is: Test if the parameter type is a type generated using a template declaration `TD`
and an argument list `(T1, ..., Tn)`. In essence, this is `if (parameterType is templateInstance)` but we
just make it clear that we want the information provided by `Gen` and also its constraints.

If `TD` is an alias template declaration, then `TD.aliasedType` is the type that `TD` aliases.
Example:
```
struct TestType(T) { }
alias TestAlias(T) = TestType!T
```
`.aliasedType` of `alias TestAlias(T)` is `TestType!T`.
If that type is an instantiation of a template declaration, we find that declaration using `findTempDecl()`. This function given the instance of a template declaration, finds that template declaration. <br/>
Notice that if it isn't a template instance, we stop. This is important, because there are other reasons that we want to stop that have to do with the implementation. More on that in the article referenced above.

`matchParams()` is a function that takes 2 arguments. One argument list (call it `al`) and one parameter map (call it `m`, a map of
formal parameters to arguments / type declarators). `al` is of course a list of template arguments.
It generates a new argument list so any formal parameter used in some argument in `al` is replaced
with the argument that it maps to (using the `m`).

A sample loop execution:
```
struct TestType(W) { }
parameterType := TestAlias!(int*, float)
// Gen looks like this: Gen(alias TestAlias(Q, S) = TestType!Q, (int*, float)) -> TestAlias!(int*, float)
TD := alias TestAlias(Q, S) = TestType!Q
(T1, ..., Tn) := (int*, float)  (where T1 := int* and T2 := float)
parameterType := TestAlias!(int*, float)
parameterType.paramMap := { Q: int*, S: float }
TD.aliasedType := TestType!Q
newTD := struct TestType(W) { }
aliasedType.paramList := (Q)
newArgumentList = (int*)  // 'Q' was replaced by int* using the map
parameterType = TestType!(int*)
```

Finally, there's one important caveat. There is a possibility that changing the parameter type to the actual
type is not enough. Consider this example:
```
struct TestType(W) {}
alias TestAlias(S, V) = TestType!(S);
void testFunction(T, Q)(TestAlias!(T, Q) arg) {}
```
Using the above logic, the parameter resolves to this:
```
void testFunction(T, Q)(TestType!T arg) {}
```
Notice that this does not compile. The reason is that `Q` is never used. It was _dropped_ in the process
of resolving the alias. For the specification to be complete, we need to consider that if in the resolution
process, a formal parameter of the function is dropped, then the type of the function has to change in more ways than
the function parameters. Its template parameters should also be reduced.
